// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "Utils.cginc"
#include "VoxelRayTracerDatas.cginc"
#include "VoxelMaterialLink.cginc"

SamplerState PointClampSampler;
Texture3D<uint> voxel;
TextureCube<float4> cubemap;
RWTexture2D<float4> Result;


//#define HD 1


float3 iCameraPos;
float4 iCameraRot;
float iCameraFOV;

int iMaxSteps = 120;
int iVolumetricLightSteps = 120;
float iTime = 0;
float2 iResolution;
int iBlurIteration = 1;
int iShadowIteration = 1;

int iReflectionCount = 2;
#define MAXREFLECTIONCOUNT 10

float3 lightPos;



/*
float getVoxel(int3 c)
 {
	float3 p = float3(c) + float3(0.5, 0.5, 0.5);
	float d = min(max(-sdSphere(p  + sin(iTime), 7.5), sdBox(p, float3(7.0, 7.0, 7.0))), -sdSphere(p, 25.0));
    d = min(d, p.y + 10.);
	return d;
}
*/
float getVoxelTransparent(int3 c) {
	int3 p = float3(c) + tofloat3(0.5);
   
	float d = sdSphere(p, 1. + 0.5 * sin(iTime));
	return d;
}


struct BoxIntersectionResult
{
    bool hasHit;
    float dist1;
    float dist2; 
};

// struct RayHit
// {
//     float3 ro;
//     float3 rd;
    
//     bool hasHit;
//     float3 pos;
//     float dist;
//     float dist2; //calculate the second ray intersection

//     float3 normal;
//     float3 reflDir;
//     float2 uv;
//     int3 cell;
// };

BoxIntersectionResult BoxIntersection(float3 bmin, float3 bmax, float3 ro, float3 rd)
{
    float3 invRd = 1. / rd;
    float tx1 = (bmin.x - ro.x)*invRd.x;
    float tx2 = (bmax.x - ro.x)*invRd.x;

    float tmin = min(tx1, tx2);
    float tmax = max(tx1, tx2);

    float ty1 = (bmin.y - ro.y)*invRd.y;
    float ty2 = (bmax.y - ro.y)*invRd.y;

    tmin = max(tmin, min(ty1, ty2));
    tmax = min(tmax, max(ty1, ty2));

    float tz1 = (bmin.z - ro.z)*invRd.z;
    float tz2 = (bmax.z - ro.z)*invRd.z;

    tmin = max(tmin, min(tz1, tz2));
    tmax = min(tmax, max(tz1, tz2));

    BoxIntersectionResult intersection;
    intersection.hasHit = tmax >= tmin; 
    intersection.dist1 = tmin;
    intersection.dist2 = tmax;
    return intersection;
}

float2 GetUV(RayHit hit)
{
    float3 n = abs(hit.normal);
    if(n.x > 0.5)
    {
        return hit.pos.zy;
    }
    if(n.y > 0.5)
    {
        return hit.pos.xz;
    }
    //if(n.z > 0.5)
    {
        return hit.pos.xy;
    }
}


RayHit CalculateRayHit(float3 rayPos, float3 rayDir, int3 mapPos, bool3 mask)
{
    BoxIntersectionResult intersection = BoxIntersection(float3(mapPos), float3(mapPos + 1), rayPos, rayDir);
    float3 normal = float3(mask);
    normal *= sign(-rayDir);
    
    RayHit hit;
    hit.ro = rayPos;
    hit.rd = rayDir;
    hit.hasHit = intersection.hasHit;
    hit.dist = intersection.dist1;
    hit.dist2 = intersection.dist2;
    hit.pos = rayPos + rayDir * intersection.dist1;
    hit.normal = normal;
    hit.reflDir = reflect(rayDir, normal);
    hit.cell = mapPos;
    hit.uv = GetUV(hit); //validate uv
    hit.materialID = voxel[mapPos];
    return hit;
}

bool3 lessThanEqual(float3 a, float3 b)
{
    return bool3(a <= b);
}

RayHit RayCast(float3 ro, float3 rd)
{
	int3 mapPos = int3(floor(ro + 0.));

    //todo comprendre wtf que ça fait ça
    float lengthRayDir = length(rd);
	float3 deltaDist = abs(lengthRayDir / rd);
	int3 rayStep = int3(sign(rd));
	float3 sideDist = (sign(rd) * (float3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; 
    
    bool3 mask;
	
    int i;
	for (i = 0; i < iMaxSteps; i++) 
    {
        if (voxel[mapPos] != 0) break;

        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));

        sideDist += float3(mask) * deltaDist;
        mapPos += int3(float3(mask)) * rayStep;

	}
	
    if(i == iMaxSteps)
    {
        RayHit hit;
        hit.ro = ro;
        hit.rd = rd;
        hit.hasHit = false;
        return hit;
    }

    return CalculateRayHit(ro, rd, mapPos, mask);
}

float VolumetricNoise(float3 p)
{
    return 0.75;
    // float f;
    // f  = 0.5000 * texture( iChannel1, p * 2. ).x;
    // f += 0.2500 * texture( iChannel1, p * 4. ).x;
    // f += 0.1250 * texture( iChannel1, p * 8. ).x;
    // f += 0.0800 * texture( iChannel1, p * 16.).x;
    // f += 0.0625 * texture( iChannel1, p * 32.).x;   
    // return f;
}

float Light(RayHit hit)
{
    lightPos = 0. * float3(sin(iTime), 0.0, cos(iTime));
    lightPos = float3(50, 25, 50);

    float3 ldir = normalize(lightPos - hit.pos);
    float diffuse = dot(hit.normal, ldir);
    diffuse =  max(0.0, diffuse);
    
    float lightDist = distance(hit.pos, lightPos);
    float ambient = 0.5;
    

    //Specular
    float specularStrength = 0.35;
    float3 reflectDir = reflect(ldir, hit.normal);  
    float spec = pow(max(dot(hit.rd, reflectDir), 0.0), 8.0);
    float specular = specularStrength * spec;  
    

    //shadow
    float umbraStrength = 0.5;
    
    float shadow = 1.0;
#ifdef HD    
    float lightSoftShadow = 0.15;

    int shadowHits = 0;
    for(int i = 0; i < iShadowIteration; i++)
    {
        float3 tempLightPos = lightPos + lightSoftShadow * ShittyRandom(float(i));
        float3 templdir = normalize(tempLightPos - hit.pos);
        
        RayHit shadowRay = RayCast(hit.pos + hit.normal * 0.001, templdir);
        if(shadowRay.dist < lightDist)
        {
            shadowHits++;
        }
    }
    float shadowRatio = (float(shadowHits) / float(iShadowIteration));
    shadow = 1. - umbraStrength * shadowRatio * shadowRatio * shadowRatio; 
    
#else
    RayHit shadowRay = RayCast(hit.pos + hit.normal * 0.001, ldir);
    if(shadowRay.dist < lightDist)
    {
        shadow = 1. - umbraStrength;
    }
#endif
    float lightDistStrg = lightDist/50.;
    lightDistStrg = clamp(lightDistStrg * lightDistStrg * lightDistStrg, 0.0, 1.0) * 0.5;
    
    
    float finalLightIntensity = (diffuse + specular) * shadow + ambient - lightDistStrg;
    return saturate(finalLightIntensity);
}

float3 GetColor(RayHit hit)
{
    if(!hit.hasHit)
    {
        return cubemap.SampleLevel(PointClampSampler, hit.rd, 1).rgb;       
    }

    return GetColor(hit.materialID, hit);

    float3 col = hsv2rgb(float3(frac(hit.normal.x * 2.5 + hit.normal.y * .63 + hit.normal.z * 2.125), 0.5, 1.0));
    col = clamp(col, 0.0, 1.0);    
    return col * Light(hit);
}

float4 RayCastTransparent(float3 rayPos, float3 rayDir, float maxDist)
{
	int3 mapPos = int3(floor(rayPos + 0.));
    float rayLength = length(rayDir);
	float3 deltaDist = abs(float3(rayLength, rayLength, rayLength) / rayDir);
	int3 rayStep = int3(sign(rayDir));
	float3 sideDist = (sign(rayDir) * (float3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; 
    
    bool3 mask;
	
    float transparency = 0.025;
    float4 sumColor = tofloat4(0.0);
    
	for (int i = 0; i < iMaxSteps; i++) 
    {
        //optimize this
        if(distancesq(float3(mapPos), rayPos) > maxDist * maxDist) break;
        
		if (getVoxelTransparent(mapPos) < 0.)
        {
            RayHit hit = CalculateRayHit(rayPos, rayDir, mapPos, mask);
            float3 col = GetColor(hit);
            float boxDepth = abs(hit.dist - hit.dist2);
            sumColor += float4(col, 1.0) * boxDepth * transparency;          
        }
        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));

        sideDist += float3(mask) * deltaDist;
        mapPos += int3(float3(mask)) * rayStep;
	}
	
    return saturate(sumColor);
}

float3 Blend(float3 opaque, float4 transparent)
{
    //overlay blending
    //return transparent.a < 0.5 ?
    //    2. * opaque * transparent.rgb :
    //    1. - 2. * (1. - opaque) * (1. - transparent.rgb);

    //return mix(opaque, transparent.rgb, transparent.a);
    
    //additive
    return saturate(opaque + transparent.rgb *transparent.a);
}



float4 CalculateVolumetricLight(float3 ro, float3 rd, float maxDist)
{
    float hardMaxDist = 100.;
    float dx = hardMaxDist / float(iVolumetricLightSteps);
    
    float lightStrength = 0.02;
    float lightSum = 0.;
    
    for(int i = 0; i < iVolumetricLightSteps; i++)
    {
        float currentDist = float(i) * dx;
        if(currentDist > maxDist) break;
        
        float3 p = ro + rd * currentDist;
        float3 d = lightPos - p;
        float l = length(d);
        RayHit hit = RayCast(p, d/l);
        if(!hit.hasHit || l < hit.dist)
        {
            float vNoise = VolumetricNoise(p);
            vNoise = Remap(0., 1., 0.5, 1., vNoise); 
            lightSum += lightStrength * dx * vNoise;
            //try this shit *= exp(-cloud * dStep);
        }
    }
    return tofloat4(lightSum);
}


void RenderRay(float3 ro, float3 rd, out float3 col, out float obstruction, out RayHit hit)
{
    hit = RayCast(ro, rd);

    float3 hitColor = GetColor(hit);
    float4 transparentColor = RayCastTransparent(ro, rd, hit.dist);
    float4 volumetricLight = CalculateVolumetricLight(ro, rd, hit.dist);   
    col = Blend(hitColor, transparentColor + volumetricLight);

    obstruction = transparentColor.a + volumetricLight.a;
}

void PerspectiveCam(float3 camPos, float4 camRot, float2 uv, float fov, out float3 ro, out float3 rd)
{
    //Add FOV
    float3 forward = normalize(float3(uv.x, uv.y, 1.0));
    ro = camPos;
    rd = qmul(camRot, forward);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{

    float2 uv = (float2(id.xy) / iResolution.xy) * 2.0 - 1.0;
    float3 ro, rd;

    PerspectiveCam(iCameraPos, iCameraRot, uv, iCameraFOV, ro, rd);

	RayHit hit;
    
    float3 reflColors[MAXREFLECTIONCOUNT];
    float obstructions[MAXREFLECTIONCOUNT];

    for(int j = 0; j < MAXREFLECTIONCOUNT; j++)
    {
        reflColors[j] = 0;
        obstructions[j] = 0;
    }

    float blur = 0.0;
        
    int lastReflectionId = 0;
    int i = 0;
    for(i = 0; i < iReflectionCount; i++)
    {
#ifdef HD
        if(blur == 0.0)
        {
            RenderRay(ro, rd, reflColors[i], obstructions[i], hit);
            //Result[id.xy] = float4(reflColors[i], 1.0);
            //return;
        }
        else    
        {
            reflColors[i] = 0;
            obstructions[i] = 0.;
            for(int j = 0; j < iBlurIteration; j++)
            {
                float3 shitRandom = blur * ShittyRandom(float(j));
                float3 relfCol;
                float obstruction;
                RenderRay(ro, normalize(rd + shitRandom), relfCol, obstruction, hit);

                reflColors[i] += relfCol;
                obstructions[i] += obstruction;
            }
            reflColors[i] /= float(iBlurIteration);
            obstructions[i] /= float(iBlurIteration);
        }
#else

        RenderRay(ro, rd, reflColors[i], obstructions[i], hit);
        
#endif  
             
        ro = hit.pos + hit.normal * 0.01;
        rd = hit.reflDir;
        blur = 0.01;
        lastReflectionId = i;

        if(obstructions[i] > 0.95 || !hit.hasHit)
        {
            break;
        }
    }
    
    float3 col = reflColors[lastReflectionId];

    for(i = lastReflectionId - 1; i >= 0; i--)
    {
        //Make transparency remove some reflectivity
        float reflection = 0.2 * (1. - obstructions[i]); 
        //float reflection = 0.8 * (sin(iTime) * 0.5 + 0.5) * (1. - obstructions[i]); 

        col = lerp(reflColors[i], col, reflection);
        //col = mix(reflColors[i], col, REFLECTION * Luminance(reflColors[i]));
    }    
    

    Result[id.xy] = float4(col, 1.0);
}
