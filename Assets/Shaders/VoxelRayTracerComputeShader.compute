
#ifndef _VoxelRayTracerComputeShader
#define _VoxelRayTracerComputeShader
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


#include "VoxelRayTracerDatas.cginc"
#include "VoxelMaterialLink.cginc"
#include "VoxelRayCaster.cginc"


//#include "Utils/LightUtils.cginc"
#include "Utils/MathUtils.cginc"

SamplerState PointClampSampler;
Texture3D<uint> voxel;
TextureCube<float4> cubemap;
RWTexture2D<float4> Result;


//#define HD 1

float3 iCameraPos;
float4 iCameraRot;
float iCameraFOV;

int iMaxSteps = 120;
int iVolumetricLightSteps = 120;
int iBlurIteration = 1;
int iShadowIteration = 1;

float2 iResolution;
float iTime = 0;

int iReflectionCount = 2;
#define MAXREFLECTIONCOUNT 10

float3 lightPos;

float getVoxelTransparent(int3 c) {
	int3 p = float3(c) + 0.5;
   
	float d = sdSphere(p, 1. + 0.5 * sin(iTime));
	return d;
}

RayHit RayCast(float3 ro, float3 rd)
{
    return RayCastWithVoxel(ro, rd, iMaxSteps, voxel);
}

Material GetColor(RayHit hit)
{
    if(!hit.hasHit)
    {
        Material material;
        material.blur = 0;
        material.reflection = 0;
        material.color = cubemap.SampleLevel(PointClampSampler, hit.rd, 1).rgb;
        return material;
    }


    LightData lightData;
    lightData.color = hsv2rgb(float3(iTime * 0.2, 0.3, 1.));
    lightData.intensity = 1;
    lightData.penumbraRadius = 1;
    lightData.position = float3(50, 25, 50) + 10 * float3(sin(iTime), 0, cos(iTime));
    lightData.radius = 100;

    Settings settings;
    settings.blurIterations = iBlurIteration;
    settings.shadowIterations = iShadowIteration;
    settings.volumetricLightSteps = iVolumetricLightSteps;
    settings.maxSteps = iMaxSteps;

    return GetColor(hit.materialID, lightData, hit, settings, voxel);
}

float4 RayCastTransparent(float3 rayPos, float3 rayDir, float maxDist)
{
	int3 mapPos = int3(floor(rayPos + 0.));
    float rayLength = length(rayDir);
	float3 deltaDist = abs(float3(rayLength, rayLength, rayLength) / rayDir);
	int3 rayStep = int3(sign(rayDir));
	float3 sideDist = (sign(rayDir) * (float3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; 
    
    bool3 mask;
	
    float transparency = 0.025;
    float4 sumColor = 0.0;
    
	for (int i = 0; i < iMaxSteps; i++) 
    {
        //optimize this
        if(distancesq(float3(mapPos), rayPos) > maxDist * maxDist) break;
        
		if (getVoxelTransparent(mapPos) < 0.)
        {
            RayHit hit = CalculateRayHit(rayPos, rayDir, mapPos, mask, voxel);
            float3 col = GetColor(hit).color;
            float boxDepth = abs(hit.dist - hit.dist2);
            sumColor += float4(col, 1.0) * boxDepth * transparency;          
        }
        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));

        sideDist += float3(mask) * deltaDist;
        mapPos += int3(float3(mask)) * rayStep;
	}
	
    return saturate(sumColor);
}

float3 Blend(float3 opaque, float4 transparent)
{
    //overlay blending
    //return transparent.a < 0.5 ?
    //    2. * opaque * transparent.rgb :
    //    1. - 2. * (1. - opaque) * (1. - transparent.rgb);

    //return mix(opaque, transparent.rgb, transparent.a);
    
    //additive
    return saturate(opaque + transparent.rgb *transparent.a);
}



float4 CalculateVolumetricLight(float3 ro, float3 rd, float maxDist)
{
    float hardMaxDist = 100.;
    float dx = hardMaxDist / float(iVolumetricLightSteps);
    
    float lightStrength = 0.02;
    float lightSum = 0.;
    
    for(int i = 0; i < iVolumetricLightSteps; i++)
    {
        float currentDist = float(i) * dx;
        if(currentDist > maxDist) break;
        
        float3 p = ro + rd * currentDist;
        float3 d = lightPos - p;
        float l = length(d);
        RayHit hit = RayCast(p, d/l);
        if(!hit.hasHit || l < hit.dist)
        {
            //float vNoise = VolumetricNoise(p);
            //vNoise = Remap(0., 1., 0.5, 1., vNoise); 
            //lightSum += lightStrength * dx * vNoise;
            lightSum += lightStrength * dx;
            //try this shit *= exp(-cloud * dStep);
        }
    }
    return lightSum;
}


void RenderRay(float3 ro, float3 rd, out Material material, out float obstruction, out RayHit hit)
{
    hit = RayCast(ro, rd);

    material = GetColor(hit);
    float4 transparentColor = RayCastTransparent(ro, rd, hit.dist);
    float4 volumetricLight = CalculateVolumetricLight(ro, rd, hit.dist);   
    material.color = Blend(material.color, transparentColor + volumetricLight);

    obstruction = transparentColor.a + volumetricLight.a;
}

void PerspectiveCam(float3 camPos, float4 camRot, float2 uv, float fov, out float3 ro, out float3 rd)
{
    //Add FOV
    float3 forward = normalize(float3(uv.x, uv.y, 1.0));
    ro = camPos;
    rd = qmul(camRot, forward);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{

    float2 uv = (float2(id.xy) / iResolution.xy) * 2.0 - 1.0;
    float3 ro, rd;

    PerspectiveCam(iCameraPos, iCameraRot, uv, iCameraFOV, ro, rd);

	RayHit hit;
    
    float3 reflColors[MAXREFLECTIONCOUNT];
    Material reflMaterial[MAXREFLECTIONCOUNT];
    float obstructions[MAXREFLECTIONCOUNT];

    for(int j = 0; j < MAXREFLECTIONCOUNT; j++)
    {
        reflColors[j] = 0;
        obstructions[j] = 0;
    }

    float blur = 0.0;
        
    int lastReflectionId = 0;
    int i = 0;
    for(i = 0; i < iReflectionCount; i++)
    {
#ifdef HD
        if(blur == 0.0)
        {
            RenderRay(ro, rd, reflMaterial[i], obstructions[i], hit);
        }
        else    
        {
            reflColors[i] = 0;
            obstructions[i] = 0.;
            for(int j = 0; j < iBlurIteration; j++)
            {
                float3 shitRandom = blur * ShittyRandom(float(j));
                float3 relfCol;
                float obstruction;
                RenderRay(ro, normalize(rd + shitRandom), relfCol, obstruction, hit);

                reflMaterial[i] += relfCol;
                obstructions[i] += obstruction;
            }
            reflColors[i] /= float(iBlurIteration);
            obstructions[i] /= float(iBlurIteration);
        }
#else

        RenderRay(ro, rd, reflMaterial[i], obstructions[i], hit);
        
#endif  
             
        ro = hit.pos + hit.normal * 0.01;
        rd = hit.reflDir;
        blur = 0.01;
        lastReflectionId = i;

        if(obstructions[i] > 0.95 || !hit.hasHit)
        {
            break;
        }
    }
    
    Material material = reflMaterial[lastReflectionId];
    float3 col = material.color;

    for(i = lastReflectionId - 1; i >= 0; i--)
    {
        //Make transparency remove some reflectivity

        //TODO take material reflection here
        material = reflMaterial[i];
        float reflection = material.reflection * (1. - obstructions[i]); 
        //float reflection = 0.8 * (sin(iTime) * 0.5 + 0.5) * (1. - obstructions[i]); 

        col = lerp(material.color, col, reflection);
        //col = mix(reflColors[i], col, REFLECTION * Luminance(reflColors[i]));
    }    
    

    Result[id.xy] = float4(col, 1.0);
}

#endif