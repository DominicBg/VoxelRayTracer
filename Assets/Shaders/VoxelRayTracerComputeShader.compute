
#ifndef _VoxelRayTracerComputeShader
#define _VoxelRayTracerComputeShader
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


#include "VoxelRayTracerDatas.cginc"
#include "VoxelMaterialLink.cginc"
#include "VoxelRayCaster.cginc"


//#include "Utils/LightUtils.cginc"
#include "Utils/MathUtils.cginc"

SamplerState PointClampSampler;
Texture3D<uint> voxel;
TextureCube<float4> cubemap;
RWTexture2D<float4> Result;
StructuredBuffer<LightData> lightDatas;

#define MAXREFLECTIONCOUNT 10

//Inputs
float3 iCameraPos;
float4 iCameraRot;
float iCameraFOV;
int iMaxSteps = 120;
int iVolumetricLightSteps = 120;
int iBlurIteration = 1;
int iShadowIteration = 1;
float2 iResolution;
float iTime = 0;
int iReflectionCount = 2;

//Local
SceneData sceneData;
Settings settings;

//TODO remove and put a Texture3D<uint> transparentVoxel;
float getVoxelTransparent(int3 c)
 {
	int3 p = float3(c) + 0.5;
   
	float d = sdSphere(p, 1. + 0.5 * sin(iTime));
	return d;
}

RayHit RayCast(float3 ro, float3 rd)
{
    return RayCast(ro, rd, sceneData);
}

Material GetColor(RayHit hit)
{
    if(!hit.hasHit)
    {
        Material material;
        material.blur = 0;
        material.reflection = 0;
        material.color = cubemap.SampleLevel(PointClampSampler, hit.rd, 1).rgb;
        return material;
    }

    return GetColor(hit.materialID, sceneData, hit);
}

float4 RayCastTransparent(float3 rayPos, float3 rayDir, float maxDist)
{
	int3 mapPos = int3(floor(rayPos + 0.));
    float rayLength = length(rayDir);
	float3 deltaDist = abs(float3(rayLength, rayLength, rayLength) / rayDir);
	int3 rayStep = int3(sign(rayDir));
	float3 sideDist = (sign(rayDir) * (float3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; 
    
    bool3 mask;
	
    float transparency = 0.025;
    float4 sumColor = 0.0;
    
	for (int i = 0; i < iMaxSteps; i++) 
    {
        //optimize this
        if(distancesq(float3(mapPos), rayPos) > maxDist * maxDist) break;
        
		if (getVoxelTransparent(mapPos) < 0.)
        {
            RayHit hit = CalculateRayHit(rayPos, rayDir, mapPos, mask, voxel);
            float3 col = GetColor(hit).color;
            float boxDepth = abs(hit.dist - hit.dist2);
            sumColor += float4(col, 1.0) * boxDepth * transparency;          
        }
        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));

        sideDist += float3(mask) * deltaDist;
        mapPos += int3(float3(mask)) * rayStep;
	}
	
    return saturate(sumColor);
}

float3 Blend(float3 opaque, float4 transparent)
{
    //overlay blending
    //return transparent.a < 0.5 ?
    //    2. * opaque * transparent.rgb :
    //    1. - 2. * (1. - opaque) * (1. - transparent.rgb);

    //return mix(opaque, transparent.rgb, transparent.a);
    
    //additive
    return saturate(opaque + transparent.rgb *transparent.a);
}


void RenderRay(float3 ro, float3 rd, out Material material, out float obstruction, out RayHit hit)
{
    hit = RayCast(ro, rd);

    material = GetColor(hit);

    float maxDist = hit.hasHit ?  hit.dist : 9999;

    float4 transparentColor = RayCastTransparent(ro, rd, maxDist);
    float4 volumetricLight = CalculateVolumetricLight(ro, rd, maxDist, sceneData);   
    material.color = Blend(material.color, transparentColor + volumetricLight);

    obstruction = transparentColor.a + volumetricLight.a;
}

void PerspectiveCam(float3 camPos, float4 camRot, float2 uv, float fov, out float3 ro, out float3 rd)
{
    //Add FOV
    float3 forward = normalize(float3(uv.x, uv.y, 1.0));
    ro = camPos;
    rd = qmul(camRot, forward);
}

void PrepareSceneData()
{
    settings.blurIterations = iBlurIteration;
    settings.shadowIterations = iShadowIteration;
    settings.volumetricLightSteps = iVolumetricLightSteps;
    settings.maxSteps = iMaxSteps;

    sceneData.lightDatas = lightDatas;
    sceneData.settings = settings;
    sceneData.voxel = voxel;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    PrepareSceneData();

    float2 uv = (float2(id.xy) / iResolution.xy) * 2.0 - 1.0;
    float3 ro, rd;

    PerspectiveCam(iCameraPos, iCameraRot, uv, iCameraFOV, ro, rd);

	RayHit hit;
    
    Material reflMaterial[MAXREFLECTIONCOUNT];
    float obstructions[MAXREFLECTIONCOUNT];

    float blur = 0.0;
        
    int lastReflectionId = 0;
    int i = 0;
    for(i = 0; i < iReflectionCount; i++)
    {
        if(blur == 0.0 || iBlurIteration == 1)
        {
            RenderRay(ro, rd, reflMaterial[i], obstructions[i], hit);
        }
        else    
        {
            //main ray
            RenderRay(ro, rd, reflMaterial[i], obstructions[i], hit);

            float3 blurCol = reflMaterial[i].color;
            for(int j = 0; j < iBlurIteration; j++)
            {
                float3 shitRandom = blur * ShittyRandom(float(j));
                Material reflMat;
                float obstruction;
                RenderRay(ro, normalize(rd + shitRandom), reflMat, obstruction, hit);

                blurCol += reflMat.color;
                obstructions[i] += obstruction;
            }

            reflMaterial[i].color = blurCol / float(iBlurIteration + 1);
            obstructions[i] /= float(iBlurIteration + 1);
        }
             
        ro = hit.pos + hit.normal * 0.01;
        rd = hit.reflDir;
        blur = 0.01;
        lastReflectionId = i;

        if(obstructions[i] > 0.95 || !hit.hasHit)
        {
            break;
        }
    }
    
    Material material = reflMaterial[lastReflectionId];
    float3 col = material.color;

    for(i = lastReflectionId - 1; i >= 0; i--)
    {
        //Make transparency remove some reflectivity

        //TODO take material reflection here
        material = reflMaterial[i];
        float reflection = material.reflection * (1. - obstructions[i]); 
        //float reflection = 0.8 * (sin(iTime) * 0.5 + 0.5) * (1. - obstructions[i]); 

        col = lerp(material.color, col, reflection);
        //col = mix(reflColors[i], col, REFLECTION * Luminance(reflColors[i]));
    }    
    

    Result[id.xy] = float4(col, 1.0);
}

#endif