
#ifndef _VoxelRayTracerComputeShader
#define _VoxelRayTracerComputeShader
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


#include "VoxelRayTracerDatas.cginc"
#include "VoxelMaterialLink.cginc"
#include "VoxelRayCaster.cginc"
#include "GPUCamera.cginc"


//#include "Utils/LightUtils.cginc"
#include "Utils/MathUtils.cginc"

SamplerState PointClampSampler;
Texture3D<uint> voxel;
Texture3D<uint> voxelTransparent;

TextureCube<float4> cubemap;
RWTexture2D<float4> Result;
StructuredBuffer<LightData> lightDatas;

#define MAXREFLECTIONCOUNT 10

//Inputs


//Cams
bool iUseFreeCamera;

float3 iCameraPos;
float4 iCameraRot;
float iCameraFOV;

float4x4 iCameraToWorld;
float4x4 iCameraInverseProjection;

int iMaxSteps = 120;
int iVolumetricLightSteps = 120;
int iBlurIteration = 1;
int iShadowIteration = 1;
float2 iResolution;
float iTime = 0;
int iReflectionCount = 2;

float3 iVoxelSizes;
float3 iVoxelTransparentSizes;

//Debug
bool iNormalDebugView;
bool iReflectedDirDebugView;
bool iUVDebugView;
bool iLightOnlyDebugView;

//Local
SceneData sceneData;
Settings settings;

Material GetColor(inout RayHit hit)
{
    if(!hit.hasHit)
    {
        Material material;
        material.blur = 0;
        material.reflection = 0;
        material.color = cubemap.SampleLevel(PointClampSampler, hit.rd, 1).rgb;
        return material;
    }

    return GetColor(hit.materialID, sceneData, hit);
}

float4 RayCastTransparent(float3 rayPos, float3 rayDir, float maxDist)
{
	int3 mapPos = int3(floor(rayPos + 0.));
    float rayLength = length(rayDir);
	float3 deltaDist = abs(float3(rayLength, rayLength, rayLength) / rayDir);
	int3 rayStep = int3(sign(rayDir));
	float3 sideDist = (sign(rayDir) * (float3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; 
    
    bool3 mask;
	
    float transparency = 0.125;
    float4 sumColor = 0.0;
    
    [loop]
	for (int i = 0; i < iMaxSteps; i++) 
    {
        //optimize this
        if(distancesq(float3(mapPos), rayPos) > maxDist * maxDist) break;
        
		if (voxelTransparent[mapPos] != 0)
        {
            RayHit hit = CalculateRayHit(rayPos, rayDir, mapPos, mask, voxelTransparent);
            float3 col = GetColor(hit).color;
            float boxDepth = abs(hit.dist - hit.dist2);
            sumColor += float4(col, 1.0) * boxDepth * transparency;          
        }
        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));

        sideDist += float3(mask) * deltaDist;
        mapPos += int3(float3(mask)) * rayStep;
	}
	
    return saturate(sumColor);
}

float3 Blend(float3 opaque, float4 transparent)
{
    //overlay blending
    //return transparent.a < 0.5 ?
    //    2. * opaque * transparent.rgb :
    //    1. - 2. * (1. - opaque) * (1. - transparent.rgb);

    //return mix(opaque, transparent.rgb, transparent.a);
    
    //additive
    return saturate(opaque + transparent.rgb *transparent.a);
}


void RenderRay(float3 ro, float3 rd, out Material material, out float obstruction, inout RayHit hit)
{
    hit = RayCast(ro, rd, sceneData);

    material = GetColor(hit);

    float maxDist = hit.hasHit ?  hit.dist : 9999;

    float4 transparentColor = RayCastTransparent(ro, rd, maxDist);
    float4 volumetricLight = CalculateVolumetricLight(ro, rd, maxDist, sceneData);   
    material.color = Blend(material.color, transparentColor + volumetricLight);

    obstruction = transparentColor.a + volumetricLight.a;
}

void PerspectiveCam(float3 camPos, float4 camRot, float2 uv, float fov, out float3 ro, out float3 rd)
{
    //Add FOV
    float3 forward = normalize(float3(uv.x, uv.y, 1.0));
    ro = camPos;
    rd = qmul(camRot, forward);
}

void PrepareSceneData()
{
    settings.blurIterations = iBlurIteration;
    settings.shadowIterations = iShadowIteration;
    settings.volumetricLightSteps = iVolumetricLightSteps;
    settings.maxSteps = iMaxSteps;

    sceneData.lightDatas = lightDatas;
    sceneData.settings = settings;
    sceneData.voxel = voxel;
    sceneData.time = iTime;
    sceneData.voxelSizes = iVoxelSizes;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    PrepareSceneData();

    float2 uv = (float2(id.xy) / iResolution.xy) * 2.0 - 1.0;
    float3 ro, rd;

    if(iUseFreeCamera)
    {   
        PerspectiveCam(iCameraPos, iCameraRot, uv, iCameraFOV, ro, rd);
    }
    else
    {
        CreateCameraRay(uv, iCameraToWorld, iCameraInverseProjection, ro, rd);
    }

    //Center voxels at 0,0,0
    ro += float3(iVoxelSizes.x, 0.0, iVoxelSizes.z) * 0.5;

	RayHit hit;
    if(iNormalDebugView)
    {            
        hit = RayCast(ro, rd, sceneData);
        Material material = GetColor(hit); //can transform the hit
        Result[id.xy] = float4(hit.normal * 0.5 + 0.5, 1.0);
        return;
    }
    if(iReflectedDirDebugView)
    {            
        hit = RayCast(ro, rd, sceneData);
        Material material = GetColor(hit); //can transform the hit
        Result[id.xy] = float4(hit.reflDir * 0.5 + 0.5, 1.0);
        return;
    }
    if(iUVDebugView)
    {     
        hit = RayCast(ro, rd, sceneData);
        Result[id.xy] = float4(hit.uv, 0.0, 1.0);
        return;
    }
    if(iLightOnlyDebugView)
    {     
        hit = RayCast(ro, rd, sceneData);
        Result[id.xy] = float4(BasicLight(sceneData, hit), 1.0);
        return;
    }


    Material reflMaterial[MAXREFLECTIONCOUNT];
    float obstructions[MAXREFLECTIONCOUNT];

    float blur = 0.0;
        
    int lastReflectionId = 0;
    int i = 0;
    for(i = 0; i < iReflectionCount; i++)
    {
        RenderRay(ro, rd, reflMaterial[i], obstructions[i], hit);

    
        if(i != 0 && reflMaterial[i].blur > 0 && iBlurIteration > 0)
        {
            float3 blurCol = reflMaterial[i].color;
            for(int j = 0; j < iBlurIteration; j++)
            {
                float3 shitRandom = reflMaterial[i].blur * ShittyRandom(float(j));
                Material reflMat;
                float obstruction;
                RayHit blurHit;
                RenderRay(ro, normalize(rd + shitRandom), reflMat, obstruction, blurHit);

                blurCol += reflMat.color;
                obstructions[i] += obstruction;
            }

            reflMaterial[i].color = blurCol / float(iBlurIteration + 1);
            obstructions[i] /= float(iBlurIteration + 1);
        }
               
        ro = hit.pos + hit.normal * 0.01;
        rd = hit.reflDir;
        lastReflectionId = i;

        if(obstructions[i] > 0.95 || !hit.hasHit)
        {
            break;
        }
    }
    
    Material material = reflMaterial[lastReflectionId];
    float3 col = material.color;

    for(i = lastReflectionId - 1; i >= 0; i--)
    {
        material = reflMaterial[i];
        float reflection = material.reflection * (1. - obstructions[i]); 

        col = lerp(material.color, col, reflection);
    }    
    

    Result[id.xy] = float4(col, 1.0);
}

#endif